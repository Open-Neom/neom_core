import 'package:enum_to_string/enum_to_string.dart';

import '../../app_properties.dart';
import '../../utils/constants/core_constants.dart';
import '../../utils/enums/activity_feed_type.dart';
import 'app_profile.dart';
import 'app_request.dart';
import 'blog_entry.dart';
import 'event.dart';
import 'post.dart';
import 'post_comment.dart';

class ActivityFeed {

  String id;
  String ownerId; ///Owner of activity feed
  String profileId; /// Reference to profile if needed
  String profileName; ///
  String profileImgUrl;
  String message;

  String activityReferenceId;
  ActivityFeedType?  activityFeedType;
  String mediaUrl;
  int createdTime;
  bool unread;

  ActivityFeed({
      this.id = "",
      this.ownerId = "",
      this.profileId = "",
      this.profileName = "",
      this.profileImgUrl = "",
      this.message = "",
      this.activityReferenceId = "",
      this.activityFeedType,
      this.mediaUrl = "",
      this.createdTime = 0,
      this.unread = true
  });

  ActivityFeed.fromJSON(dynamic data) :
        id = data["id"] ?? "",
        ownerId = data["ownerId"] ?? "",
        profileId = data["profileId"] ?? "",
        profileName = data["profileName"] ?? "",
        profileImgUrl = data["profileImgUrl"] ?? "",
        message = data["message"] ?? "",
        activityReferenceId = data["activityReferenceId"] ?? "",
        activityFeedType = EnumToString.fromString(ActivityFeedType.values, data["activityFeedType"] ?? ActivityFeedType.comment.name),
        mediaUrl = data["mediaUrl"] ?? "",
        createdTime = data["createdTime"] ?? 0,
        unread = data["unread"] ?? true;

  Map<String, dynamic>  toJSON()=>{
//    'id': id, //generated by firebase
    'ownerId': ownerId,
    'profileId': profileId,
    'profileName': profileName,
    'profileImgUrl': profileImgUrl,
    'message': message,
    'activityReferenceId': activityReferenceId,
    'activityFeedType': activityFeedType?.name ?? "",
    'mediaUrl': mediaUrl,
    'createdTime': createdTime,
    'unread': unread,
  };

  Map<String, dynamic>  toJSONWithId()=>{
    'id': id,
    'ownerId': ownerId,
    'profileId': profileId,
    'profileName': profileName,
    'profileImgUrl': profileImgUrl,
    'message': message,
    'activityReferenceId': activityReferenceId,
    'activityFeedType': activityFeedType?.name ?? "",
    'mediaUrl': mediaUrl,
    'createdTime': createdTime,
    'unread': unread,
  };

  ActivityFeed.fromEvent({required Event event, required AppProfile fromProfile,
    required ActivityFeedType type, String msg = ''}) :
        id = '',
        ownerId = event.ownerId,
        activityReferenceId = event.id,
        mediaUrl = event.imgUrl,
        profileId = fromProfile.id,
        profileName = fromProfile.name,
        profileImgUrl = fromProfile.photoUrl,
        activityFeedType = type,
        createdTime = DateTime.now().millisecondsSinceEpoch,
        message = msg,
        unread = true;

  ActivityFeed.fromPost({required Post post, required AppProfile fromProfile,
    required ActivityFeedType type, String msg = ''}) :
        id = '',
        ownerId = post.ownerId,
        activityReferenceId = post.id,
        mediaUrl = post.mediaUrl,
        profileId = fromProfile.id,
        profileName = fromProfile.name,
        profileImgUrl = fromProfile.photoUrl,
        activityFeedType = type,
        createdTime = DateTime.now().millisecondsSinceEpoch,
        message = msg,
        unread = true;

  ActivityFeed.fromComment({required PostComment comment, required ActivityFeedType type,
    AppProfile? fromProfile, String? mediaUrl}) :
        id = '',
        ownerId = comment.ownerId,
        activityReferenceId = comment.postId,
        mediaUrl = mediaUrl ?? comment.mediaUrl,
        profileId = fromProfile?.id ?? comment.ownerId,
        profileName = fromProfile?.name ?? comment.ownerName,
        profileImgUrl = fromProfile?.photoUrl ?? comment.ownerImgUrl,
        activityFeedType = type,
        createdTime = DateTime.now().millisecondsSinceEpoch,
        message = comment.text,
        unread = true;

  ActivityFeed.fromRequest({required AppRequest request, required ActivityFeedType type,
    required AppProfile fromProfile, this.mediaUrl = '', bool isResponse = false,
    bool isEvent = true, String? message}) :
        id = '',
        ownerId = isResponse ? request.from : request.to,
        activityReferenceId = isEvent ? request.eventId : request.bandId,
        profileId = fromProfile.id,
        profileName = fromProfile.name,
        profileImgUrl = fromProfile.photoUrl,
        activityFeedType = type,
        createdTime = DateTime.now().millisecondsSinceEpoch,
        message = message ?? request.message,
        unread = true;

  ActivityFeed.fromAppBot({required String toProfileId, required referenceId,
    required ActivityFeedType type, this.message = '', this.mediaUrl = ''}) :
        id = '',
        ownerId = toProfileId,
        activityReferenceId = referenceId,
        profileId = CoreConstants.appBot,
        profileName = "${AppProperties.getAppName()} ${AppProperties.getAppBotName()}",
        profileImgUrl = AppProperties.getAppLogoUrl(),
        activityFeedType = type,
        createdTime = DateTime.now().millisecondsSinceEpoch,
        unread = true;

  /// Factory for game invitations using AppRequest
  ActivityFeed.fromGameRequest({
    required AppRequest request,
    required AppProfile senderProfile,
    required ActivityFeedType type,
    this.message = '',
  }) :
        id = '',
        ownerId = request.to, // Receiver of the game request
        activityReferenceId = request.id,
        profileId = request.from,
        profileName = senderProfile.name,
        profileImgUrl = senderProfile.photoUrl,
        mediaUrl = '',
        activityFeedType = type,
        createdTime = DateTime.now().millisecondsSinceEpoch,
        unread = true;

  /// Factory for game invitation responses (accepted/declined)
  ActivityFeed.fromGameRequestResponse({
    required AppRequest request,
    required AppProfile responderProfile,
    required ActivityFeedType type,
    this.message = '',
  }) :
        id = '',
        ownerId = request.from, // Notify the sender about response
        activityReferenceId = request.eventId, // roomId for navigation
        profileId = request.to,
        profileName = responderProfile.name,
        profileImgUrl = responderProfile.photoUrl,
        mediaUrl = '',
        activityFeedType = type,
        createdTime = DateTime.now().millisecondsSinceEpoch,
        unread = true;

  /// Factory for new blog post notifications to followers
  ActivityFeed.fromNewBlogPost({
    required Post blogPost,
    required AppProfile authorProfile,
    required String followerId,
  }) :
        id = '',
        ownerId = followerId, // Follower receives the notification
        activityReferenceId = blogPost.id,
        profileId = authorProfile.id,
        profileName = authorProfile.name,
        profileImgUrl = authorProfile.photoUrl,
        mediaUrl = blogPost.thumbnailUrl.isNotEmpty
            ? blogPost.thumbnailUrl
            : blogPost.mediaUrl,
        activityFeedType = ActivityFeedType.newBlogPost,
        createdTime = DateTime.now().millisecondsSinceEpoch,
        message = _extractBlogTitle(blogPost.caption),
        unread = true;

  /// Extracts the title from blog caption (title|||text format) or first 50 chars.
  static String _extractBlogTitle(String caption) {
    if (caption.isEmpty) return '';
    // Blog entries use "title|||text" format
    final parts = caption.split('|||');
    if (parts.isNotEmpty && parts[0].isNotEmpty) {
      return parts[0].length > 80 ? '${parts[0].substring(0, 80)}...' : parts[0];
    }
    // Fallback to first 50 chars of caption
    return caption.length > 50 ? '${caption.substring(0, 50)}...' : caption;
  }

  /// Factory for new BlogEntry notifications to followers (new model).
  ActivityFeed.fromNewBlogEntry({
    required BlogEntry blogEntry,
    required AppProfile authorProfile,
    required String followerId,
  }) :
        id = '',
        ownerId = followerId, // Follower receives the notification
        activityReferenceId = blogEntry.id,
        profileId = authorProfile.id,
        profileName = authorProfile.name,
        profileImgUrl = authorProfile.photoUrl,
        mediaUrl = blogEntry.thumbnailUrl,
        activityFeedType = ActivityFeedType.newBlogPost,
        createdTime = DateTime.now().millisecondsSinceEpoch,
        message = blogEntry.title.length > 80
            ? '${blogEntry.title.substring(0, 80)}...'
            : blogEntry.title,
        unread = true;

  /// Factory for release approval request notifications (sent to admins).
  /// [adminProfileId] - Profile ID of the admin who will review
  /// [request] - The AppRequest for release approval
  /// [authorProfile] - Profile of the author submitting the release
  /// [releaseCoverUrl] - Cover image URL of the release
  ActivityFeed.fromReleaseApprovalRequest({
    required String adminProfileId,
    required AppRequest request,
    required AppProfile authorProfile,
    String releaseCoverUrl = '',
  }) :
        id = '',
        ownerId = adminProfileId, // Admin receives the notification
        activityReferenceId = request.id,
        profileId = authorProfile.id,
        profileName = authorProfile.name,
        profileImgUrl = authorProfile.photoUrl,
        mediaUrl = releaseCoverUrl,
        activityFeedType = ActivityFeedType.releaseApprovalRequest,
        createdTime = DateTime.now().millisecondsSinceEpoch,
        message = request.message,
        unread = true;

  /// Factory for release approval/rejection notifications (sent to author).
  /// [request] - The AppRequest for release approval
  /// [isApproved] - Whether the release was approved or rejected
  /// [reviewerMessage] - Optional message from reviewer
  ActivityFeed.fromReleaseApprovalResponse({
    required AppRequest request,
    required bool isApproved,
    String reviewerMessage = '',
  }) :
        id = '',
        ownerId = request.from, // Author receives the notification
        activityReferenceId = request.eventId, // releaseItemId
        profileId = CoreConstants.appBot,
        profileName = "${AppProperties.getAppName()} ${AppProperties.getAppBotName()}",
        profileImgUrl = AppProperties.getAppLogoUrl(),
        mediaUrl = '',
        activityFeedType = isApproved
            ? ActivityFeedType.releaseApproved
            : ActivityFeedType.releaseRejected,
        createdTime = DateTime.now().millisecondsSinceEpoch,
        message = reviewerMessage.isNotEmpty
            ? reviewerMessage
            : (isApproved
                ? 'Tu publicación ha sido aprobada'
                : 'Tu publicación requiere cambios'),
        unread = true;

  /// Factory for GLOBAL new release notifications.
  /// These are stored in globalActivityFeed collection and downloaded by all users.
  /// [releaseId] - ID of the release
  /// [releaseTitle] - Title of the release
  /// [releaseCoverUrl] - Cover image URL
  /// [authorProfile] - Profile of the author who published the release
  ActivityFeed.fromGlobalNewRelease({
    required String releaseId,
    required String releaseTitle,
    required String releaseCoverUrl,
    required AppProfile authorProfile,
  }) :
        id = '',
        ownerId = '', // Empty for global notifications (not user-specific)
        activityReferenceId = releaseId,
        profileId = authorProfile.id,
        profileName = authorProfile.name,
        profileImgUrl = authorProfile.photoUrl,
        mediaUrl = releaseCoverUrl,
        activityFeedType = ActivityFeedType.newRelease,
        createdTime = DateTime.now().millisecondsSinceEpoch,
        message = releaseTitle,
        unread = true;
}
